const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, AttachmentBuilder } = require('discord.js');
const { createCanvas, loadImage } = require('canvas');
const https = require('https');
const fs = require('fs');
const path = require('path');

// ===============================================
// VALORANT STATS & API HANDLER
// ===============================================
// This handler manages Valorant account registration and stats display
// Commands: !valstats, !valprofile (user), !valtest, !valreset (admin)
// 
// IMPORTANT: This is separate from the Valorant TEAM BUILDER
// Team Builder uses: !valorant, @Valorant role, valorant_ button prefixes
// This handler uses: !valstats, !valprofile, valstats_ button prefixes
// ===============================================

// API Configuration
const API_KEY = process.env.VALORANT_API_KEY;
const BASE_URL = 'https://api.henrikdev.xyz/valorant';

// Validate API key is present
if (!API_KEY) {
    console.error('VALORANT_API_KEY is not set in environment variables!');
    throw new Error('Missing VALORANT_API_KEY environment variable');
}

// File paths for persistent storage
const DATA_DIR = path.join(__dirname, '..', 'data');
const USERS_FILE = path.join(DATA_DIR, 'valorant_users.json');

// Ensure data directory exists
if (!fs.existsSync(DATA_DIR)) {
    fs.mkdirSync(DATA_DIR, { recursive: true });
    console.log('Created data directory:', DATA_DIR);
}

// Store user registrations (loaded from file)
let userRegistrations = new Map();

// Valid regions
const VALID_REGIONS = ['na', 'eu', 'ap', 'kr', 'latam', 'br'];

// Competitive game modes for filtering
const COMPETITIVE_MODES = ['competitive', 'ranked'];

// Rank mapping with image paths
const RANK_MAPPING = {
    0: { name: 'Unranked', color: '#8D8D8D', image: 'Unranked_Rank.png' },
    3: { name: 'Iron 1', color: '#4A4A4A', image: 'Iron_1_Rank.png' },
    4: { name: 'Iron 2', color: '#4A4A4A', image: 'Iron_2_Rank.png' },
    5: { name: 'Iron 3', color: '#4A4A4A', image: 'Iron_3_Rank.png' },
    6: { name: 'Bronze 1', color: '#CD7F32', image: 'Bronze_1_Rank.png' },
    7: { name: 'Bronze 2', color: '#CD7F32', image: 'Bronze_2_Rank.png' },
    8: { name: 'Bronze 3', color: '#CD7F32', image: 'Bronze_3_Rank.png' },
    9: { name: 'Silver 1', color: '#C0C0C0', image: 'Silver_1_Rank.png' },
    10: { name: 'Silver 2', color: '#C0C0C0', image: 'Silver_2_Rank.png' },
    11: { name: 'Silver 3', color: '#C0C0C0', image: 'Silver_3_Rank.png' },
    12: { name: 'Gold 1', color: '#FFD700', image: 'Gold_1_Rank.png' },
    13: { name: 'Gold 2', color: '#FFD700', image: 'Gold_2_Rank.png' },
    14: { name: 'Gold 3', color: '#FFD700', image: 'Gold_3_Rank.png' },
    15: { name: 'Platinum 1', color: '#00CED1', image: 'Platinum_1_Rank.png' },
    16: { name: 'Platinum 2', color: '#00CED1', image: 'Platinum_2_Rank.png' },
    17: { name: 'Platinum 3', color: '#00CED1', image: 'Platinum_3_Rank.png' },
    18: { name: 'Diamond 1', color: '#B57EDC', image: 'Diamond_1_Rank.png' },
    19: { name: 'Diamond 2', color: '#B57EDC', image: 'Diamond_2_Rank.png' },
    20: { name: 'Diamond 3', color: '#B57EDC', image: 'Diamond_3_Rank.png' },
    21: { name: 'Ascendant 1', color: '#00FF7F', image: 'Ascendant_1_Rank.png' },
    22: { name: 'Ascendant 2', color: '#00FF7F', image: 'Ascendant_2_Rank.png' },
    23: { name: 'Ascendant 3', color: '#00FF7F', image: 'Ascendant_3_Rank.png' },
    24: { name: 'Immortal 1', color: '#FF6B6B', image: 'Immortal_1_Rank.png' },
    25: { name: 'Immortal 2', color: '#FF6B6B', image: 'Immortal_2_Rank.png' },
    26: { name: 'Immortal 3', color: '#FF6B6B', image: 'Immortal_3_Rank.png' },
    27: { name: 'Radiant', color: '#FFFF99', image: 'Radiant_Rank.png' }
};

// Function to load user registrations from file
function loadUserRegistrations() {
    try {
        if (fs.existsSync(USERS_FILE)) {
            const fileData = fs.readFileSync(USERS_FILE, 'utf8');
            const data = JSON.parse(fileData);
            
            // Convert object back to Map
            userRegistrations = new Map(Object.entries(data));
            console.log(`Loaded ${userRegistrations.size} registered Valorant users from file`);
            
            // Log loaded users for debugging
            userRegistrations.forEach((userData, userId) => {
                console.log(`- ${userData.name}#${userData.tag} (${userData.region}) - Discord ID: ${userId}`);
            });
        } else {
            console.log('No existing Valorant users file found, starting fresh');
            userRegistrations = new Map();
        }
    } catch (error) {
        console.error('Error loading user registrations:', error);
        userRegistrations = new Map();
    }
}

// Function to save user registrations to file
function saveUserRegistrations() {
    try {
        // Convert Map to object for JSON storage
        const dataObject = Object.fromEntries(userRegistrations);
        fs.writeFileSync(USERS_FILE, JSON.stringify(dataObject, null, 2), 'utf8');
        console.log(`Saved ${userRegistrations.size} registered Valorant users to file`);
    } catch (error) {
        console.error('Error saving user registrations:', error);
    }
}

// Function to add a new user registration
function addUserRegistration(userId, userData) {
    userRegistrations.set(userId, userData);
    saveUserRegistrations();
    console.log(`Added registration for user ${userId}: ${userData.name}#${userData.tag} (${userData.region})`);
}

// Function to remove a user registration
function removeUserRegistration(userId) {
    const userData = userRegistrations.get(userId);
    if (userData) {
        userRegistrations.delete(userId);
        saveUserRegistrations();
        console.log(`Removed registration for user ${userId}: ${userData.name}#${userData.tag}`);
        return true;
    }
    return false;
}

// Function to load rank image from filesystem
async function loadRankImage(rankTier) {
    try {
        const rankInfo = RANK_MAPPING[rankTier] || RANK_MAPPING[0];
        const imagePath = path.join(__dirname, '..', 'images', rankInfo.image);
        
        if (fs.existsSync(imagePath)) {
            return await loadImage(imagePath);
        } else {
            console.warn(`Rank image not found: ${imagePath}`);
            return null;
        }
    } catch (error) {
        console.error('Error loading rank image:', error);
        return null;
    }
}

// Function to create a fallback rank icon
function createFallbackRankIcon(ctx, x, y, size, rankInfo) {
    ctx.fillStyle = rankInfo.color;
    ctx.beginPath();
    ctx.arc(x + size/2, y + size/2, size/2 - 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Add rank initial
    ctx.fillStyle = '#ffffff';
    ctx.font = `bold ${size/3}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(rankInfo.name.charAt(0), x + size/2, y + size/2 + size/10);
}

// Enhanced function to make API requests with timeout and error handling
async function makeAPIRequest(endpoint) {
    return new Promise((resolve, reject) => {
        const url = new URL(`${BASE_URL}${endpoint}`);
        
        const options = {
            hostname: url.hostname,
            path: url.pathname + url.search,
            method: 'GET',
            headers: {
                'Authorization': API_KEY,
                'Accept': '*/*',
                'User-Agent': 'DiscordBot/1.0'
            },
            timeout: 10000 // 10 second timeout
        };

        const req = https.request(options, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    if (data.trim() === '') {
                        reject(new Error('Empty response from API'));
                        return;
                    }
                    const jsonData = JSON.parse(data);
                    console.log(`API Response for ${endpoint}:`, jsonData.status || 'No status');
                    resolve(jsonData);
                } catch (error) {
                    console.error('Failed to parse API response:', data);
                    reject(new Error('Failed to parse API response: ' + error.message));
                }
            });
        });

        req.on('timeout', () => {
            req.destroy();
            reject(new Error('API request timeout - please try again later'));
        });

        req.on('error', (error) => {
            console.error('API Request error:', error.message);
            reject(new Error('Network error: ' + error.message));
        });

        req.end();
    });
}

// Function to load image from URL with timeout
async function loadImageFromURL(url) {
    return new Promise((resolve, reject) => {
        const request = https.get(url, { timeout: 5000 }, (res) => {
            const chunks = [];
            res.on('data', (chunk) => chunks.push(chunk));
            res.on('end', () => {
                try {
                    const buffer = Buffer.concat(chunks);
                    resolve(loadImage(buffer));
                } catch (error) {
                    reject(error);
                }
            });
        });
        
        request.on('timeout', () => {
            request.destroy();
            reject(new Error('Image load timeout'));
        });
        
        request.on('error', reject);
    });
}

// Function to get user registration data
function getUserRegistration(userId) {
    return userRegistrations.get(userId);
}

// Function to get or fetch user rank data
async function getUserRankData(userId) {
    const registration = userRegistrations.get(userId);
    if (!registration) return null;

    try {
        const mmrData = await makeAPIRequest(`/v2/mmr/${registration.region}/${encodeURIComponent(registration.name)}/${encodeURIComponent(registration.tag)}`);
        if (mmrData.status === 200 && mmrData.data.current_data) {
            return mmrData.data.current_data;
        }
    } catch (error) {
        console.error('Error fetching rank data:', error);
    }
    return null;
}

// Function to get all registered users (for admin purposes)
function getAllRegisteredUsers() {
    return Array.from(userRegistrations.entries()).map(([userId, userData]) => ({
        discordId: userId,
        ...userData
    }));
}

// Enhanced function to calculate match statistics from stored matches
async function getPlayerMatchStats(registration) {
    try {
        // Use stored-matches endpoint for more comprehensive data
        const storedMatchData = await makeAPIRequest(
            `/v1/stored-matches/${registration.region}/${encodeURIComponent(registration.name)}/${encodeURIComponent(registration.tag)}`
        );

        if (storedMatchData.status !== 200 || !storedMatchData.data) {
            console.log('No stored match data available, falling back to regular matches endpoint');
            return await getPlayerMatchStatsLegacy(registration);
        }

        // Filter for competitive matches only
        const competitiveMatches = storedMatchData.data.filter(match => 
            match.meta && match.meta.mode && 
            COMPETITIVE_MODES.includes(match.meta.mode.toLowerCase())
        );

        if (competitiveMatches.length === 0) {
            console.log('No competitive matches found in stored data');
            return {
                totalKills: 0,
                totalDeaths: 1, // Avoid division by zero
                totalAssists: 0,
                totalMatches: 0,
                wins: 0,
                avgKDA: 0,
                winRate: 0,
                avgACS: 0
            };
        }

        // Take last 30 matches for more comprehensive analysis
        const recentMatches = competitiveMatches.slice(0, 30);
        
        let totalKills = 0;
        let totalDeaths = 0;
        let totalAssists = 0;
        let totalScore = 0;
        let wins = 0;
        let validMatches = 0;

        for (const match of recentMatches) {
            // Find player's stats in this match
            if (!match.stats || !match.teams) continue;
            
            const playerStats = match.stats;
            const teams = match.teams;
            
            // Check if this is the player's data (matches by PUUID if available)
            if (registration.puuid && playerStats.puuid !== registration.puuid) {
                continue;
            }
            
            totalKills += playerStats.kills || 0;
            totalDeaths += playerStats.deaths || 0;
            totalAssists += playerStats.assists || 0;
            totalScore += playerStats.score || 0;
            
            // Determine if won based on team scores
            const redScore = teams.red || 0;
            const blueScore = teams.blue || 0;
            const playerTeam = playerStats.team;
            
            let won = false;
            if (playerTeam === 'Red' && redScore > blueScore) won = true;
            if (playerTeam === 'Blue' && blueScore > redScore) won = true;
            
            if (won) wins++;
            validMatches++;
        }

        // Calculate averages and ratios
        const avgKDA = totalDeaths > 0 ? (totalKills + totalAssists) / totalDeaths : totalKills + totalAssists;
        const winRate = validMatches > 0 ? (wins / validMatches) * 100 : 0;
        const avgACS = validMatches > 0 ? totalScore / validMatches : 0;

        console.log(`Player ${registration.name}#${registration.tag} stats from ${validMatches} competitive matches:`);
        console.log(`- KDA: ${totalKills}/${totalDeaths}/${totalAssists} (${avgKDA.toFixed(2)})`);
        console.log(`- Win Rate: ${winRate.toFixed(1)}%`);
        console.log(`- Avg ACS: ${avgACS.toFixed(0)}`);

        return {
            totalKills,
            totalDeaths: Math.max(totalDeaths, 1), // Ensure never 0
            totalAssists,
            totalMatches: validMatches,
            wins,
            avgKDA,
            winRate,
            avgACS
        };

    } catch (error) {
        console.error('Error fetching stored match stats:', error);
        // Fall back to legacy method
        return await getPlayerMatchStatsLegacy(registration);
    }
}

// Legacy function for calculating match stats (fallback)
async function getPlayerMatchStatsLegacy(registration) {
    try {
        const matchData = await makeAPIRequest(
            `/v4/matches/${registration.region}/pc/${encodeURIComponent(registration.name)}/${encodeURIComponent(registration.tag)}`
        );

        if (matchData.status !== 200 || !matchData.data) {
            return {
                totalKills: 0,
                totalDeaths: 1,
                totalAssists: 0,
                totalMatches: 0,
                wins: 0,
                avgKDA: 0,
                winRate: 0,
                avgACS: 0
            };
        }

        // Filter for competitive matches only
        const competitiveMatches = matchData.data.filter(match => 
            match.metadata && match.metadata.queue.name && 
            match.metadata.queue.name.toLowerCase() === 'competitive'
        ).slice(0, 20); // Last 20 competitive matches

        if (competitiveMatches.length === 0) {
            return {
                totalKills: 0,
                totalDeaths: 1,
                totalAssists: 0,
                totalMatches: 0,
                wins: 0,
                avgKDA: 0,
                winRate: 0,
                avgACS: 0
            };
        }

        let totalKills = 0;
        let totalDeaths = 0;
        let totalAssists = 0;
        let totalScore = 0;
        let wins = 0;
        let validMatches = 0;

        for (const match of competitiveMatches) {
            const player = match.players.find(p => 
                p.name.toLowerCase() === registration.name.toLowerCase()
            );
            if (!player) continue;

            totalKills += player.stats.kills;
            totalDeaths += player.stats.deaths;
            totalAssists += player.stats.assists;
            totalScore += player.stats.score;

            const won = player.team_id === (match.teams.find(t => t.won) || {}).team_id;
            if (won) wins++;
            validMatches++;
        }

        const avgKDA = totalDeaths > 0 ? (totalKills + totalAssists) / totalDeaths : totalKills + totalAssists;
        const winRate = validMatches > 0 ? (wins / validMatches) * 100 : 0;
        const avgACS = validMatches > 0 ? totalScore / validMatches : 0;

        return {
            totalKills,
            totalDeaths: Math.max(totalDeaths, 1),
            totalAssists,
            totalMatches: validMatches,
            wins,
            avgKDA,
            winRate,
            avgACS
        };

    } catch (error) {
        console.error('Error fetching legacy match stats:', error);
        return {
            totalKills: 0,
            totalDeaths: 1,
            totalAssists: 0,
            totalMatches: 0,
            wins: 0,
            avgKDA: 0,
            winRate: 0,
            avgACS: 0
        };
    }
}

// Function to create user stats visualization - Fix parameter list
async function createStatsVisualization(accountData, mmrData, matchData, userAvatar, registration) {
    const canvas = createCanvas(1000, 800);
    const ctx = canvas.getContext('2d');
    
    // Enhanced background with pattern
    const gradient = ctx.createLinearGradient(0, 0, 1000, 800);
    gradient.addColorStop(0, '#0a0e13');
    gradient.addColorStop(0.3, '#1e2328');
    gradient.addColorStop(0.7, '#2c3e50');
    gradient.addColorStop(1, '#0a0e13');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 1000, 800);
    
    // Add subtle pattern overlay
    ctx.fillStyle = 'rgba(255, 70, 84, 0.03)';
    for (let i = 0; i < 1000; i += 50) {
        for (let j = 0; j < 800; j += 50) {
            if ((i + j) % 100 === 0) {
                ctx.fillRect(i, j, 25, 25);
            }
        }
    }
    
    // Enhanced Valorant-style accents
    const accentGradient = ctx.createLinearGradient(0, 0, 1000, 0);
    accentGradient.addColorStop(0, '#ff4654');
    accentGradient.addColorStop(0.5, '#ff6b7a');
    accentGradient.addColorStop(1, '#ff4654');
    ctx.fillStyle = accentGradient;
    ctx.fillRect(0, 0, 1000, 8);
    ctx.fillRect(0, 792, 1000, 8);
    ctx.fillRect(0, 0, 8, 800);
    ctx.fillRect(992, 0, 8, 800);
    
    // Enhanced header section
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('üéØ VALORANT PLAYER PROFILE', 500, 50);
    
    // Subtitle
    ctx.font = '16px Arial';
    ctx.fillStyle = '#cccccc';
    ctx.fillText('Powered by HenrikDev API ‚Ä¢ Enhanced Visualization v3.0 ‚Ä¢ KDA + Stored Matches', 500, 75);
    
    // User info section with enhanced styling
    const infoBoxGradient = ctx.createLinearGradient(50, 100, 950, 200);
    infoBoxGradient.addColorStop(0, 'rgba(255, 70, 84, 0.1)');
    infoBoxGradient.addColorStop(1, 'rgba(255, 107, 122, 0.1)');
    ctx.fillStyle = infoBoxGradient;
    ctx.fillRect(50, 100, 900, 100);
    ctx.strokeStyle = '#ff4654';
    ctx.lineWidth = 2;
    ctx.strokeRect(50, 100, 900, 100);
    
    try {
        // Enhanced user avatar with glow effect
        if (userAvatar) {
            const avatar = await loadImageFromURL(userAvatar);
            
            // Glow effect
            ctx.shadowColor = '#ff4654';
            ctx.shadowBlur = 15;
            ctx.save();
            ctx.beginPath();
            ctx.arc(150, 150, 45, 0, Math.PI * 2);
            ctx.clip();
            ctx.drawImage(avatar, 105, 105, 90, 90);
            ctx.restore();
            ctx.shadowBlur = 0;
            
            // Enhanced avatar border with gradient
            const borderGradient = ctx.createRadialGradient(150, 150, 40, 150, 150, 50);
            borderGradient.addColorStop(0, '#ff4654');
            borderGradient.addColorStop(1, '#ff6b7a');
            ctx.strokeStyle = borderGradient;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(150, 150, 45, 0, Math.PI * 2);
            ctx.stroke();
        }
    } catch (error) {
        // Enhanced fallback avatar
        const avatarGradient = ctx.createRadialGradient(150, 150, 0, 150, 150, 45);
        avatarGradient.addColorStop(0, '#ff6b7a');
        avatarGradient.addColorStop(1, '#ff4654');
        ctx.fillStyle = avatarGradient;
        ctx.beginPath();
        ctx.arc(150, 150, 45, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ffffff';
        ctx.font = '36px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('üë§', 150, 165);
    }
    
    // Enhanced player name and info
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`${accountData.name}#${accountData.tag}`, 220, 135);
    
    ctx.font = '16px Arial';
    ctx.fillStyle = '#e0e0e0';
    ctx.fillText(`üéÆ Level ${accountData.account_level} ‚Ä¢ üåç Region: ${accountData.region.toUpperCase()}`, 220, 160);
    ctx.fillText(`üìÖ Last Updated: ${new Date(accountData.updated_at).toLocaleDateString()}`, 220, 180);
    
    // Enhanced current rank section
    if (mmrData && mmrData.current_data) {
        const currentRank = mmrData.current_data;
        const rankInfo = RANK_MAPPING[currentRank.currenttier] || RANK_MAPPING[0];
        
        // Enhanced rank box with gradient
        const rankBoxGradient = ctx.createLinearGradient(50, 220, 950, 350);
        rankBoxGradient.addColorStop(0, 'rgba(255, 70, 84, 0.15)');
        rankBoxGradient.addColorStop(1, 'rgba(255, 107, 122, 0.15)');
        ctx.fillStyle = rankBoxGradient;
        ctx.fillRect(50, 220, 900, 130);
        ctx.strokeStyle = '#ff4654';
        ctx.lineWidth = 3;
        ctx.strokeRect(50, 220, 900, 130);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('üèÜ CURRENT COMPETITIVE RANK', 80, 250);
        
        // Load and display rank image
        const rankImage = await loadRankImage(currentRank.currenttier);
        if (rankImage) {
            ctx.drawImage(rankImage, 80, 260, 60, 60);
        } else {
            createFallbackRankIcon(ctx, 80, 260, 60, rankInfo);
        }
        
        ctx.fillStyle = rankInfo.color;
        ctx.font = 'bold 32px Arial';
        ctx.fillText(rankInfo.name, 160, 295);
        
        if (currentRank.ranking_in_tier !== undefined) {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px Arial';
            ctx.fillText(`${currentRank.ranking_in_tier} RR`, 160, 320);
        }
        
        if (currentRank.mmr_change_to_last_game) {
            const change = currentRank.mmr_change_to_last_game;
            ctx.fillStyle = change > 0 ? '#00ff88' : '#ff4444';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`Last Game: ${change > 0 ? '+' : ''}${change} RR`, 400, 295);
        }
        
        // Enhanced peak rank display
        if (mmrData.highest_rank) {
            const peakRank = RANK_MAPPING[mmrData.highest_rank.tier] || RANK_MAPPING[0];
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('üåü Peak Rank:', 600, 280);
            
            const peakRankImage = await loadRankImage(mmrData.highest_rank.tier);
            if (peakRankImage) {
                ctx.drawImage(peakRankImage, 600, 285, 40, 40);
            } else {
                createFallbackRankIcon(ctx, 600, 285, 40, peakRank);
            }
            
            ctx.fillStyle = peakRank.color;
            ctx.font = 'bold 20px Arial';
            ctx.fillText(peakRank.name, 650, 310);
        }
    }
    
    // Enhanced recent matches section - Filter for competitive matches only
    if (matchData && matchData.length > 0) {
        // Filter for competitive matches only
        const competitiveMatches = matchData.filter(match => 
            match.metadata && match.metadata.queue.name && match.metadata.queue.name.toLowerCase() === 'competitive'
        );
        
        if (competitiveMatches.length > 0) {
            // Section header with gradient background
            const matchesHeaderGradient = ctx.createLinearGradient(50, 370, 950, 400);
            matchesHeaderGradient.addColorStop(0, 'rgba(255, 70, 84, 0.2)');
            matchesHeaderGradient.addColorStop(1, 'rgba(255, 107, 122, 0.2)');
            ctx.fillStyle = matchesHeaderGradient;
            ctx.fillRect(50, 370, 900, 30);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('üìä RECENT COMPETITIVE MATCHES', 80, 390);
            
            const recentMatches = competitiveMatches.slice(0, 6);
            recentMatches.forEach((match, index) => {
                const y = 420 + index * 60;
                // Fix: Use accountData.name instead of registration.name
                const player = match.players.find(p => p.name.toLowerCase() === accountData.name.toLowerCase());
                
                if (!player) return;
                
                const won = player.team_id === (match.teams.find(t => t.won) || {}).team_id;
                
                // Enhanced match result background with gradient
                const matchGradient = ctx.createLinearGradient(50, y - 25, 950, y + 35);
                if (won) {
                    matchGradient.addColorStop(0, 'rgba(0, 255, 136, 0.15)');
                    matchGradient.addColorStop(1, 'rgba(0, 200, 100, 0.15)');
                } else {
                    matchGradient.addColorStop(0, 'rgba(255, 68, 68, 0.15)');
                    matchGradient.addColorStop(1, 'rgba(200, 50, 50, 0.15)');
                }
                ctx.fillStyle = matchGradient;
                ctx.fillRect(50, y - 25, 900, 50);
                
                ctx.strokeStyle = won ? '#00ff88' : '#ff4444';
                ctx.lineWidth = 2;
                ctx.strokeRect(50, y - 25, 900, 50);
                
                // Match result with enhanced styling using emojis
                ctx.fillStyle = won ? '#00ff88' : '#ff4444';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(won ? 'üî± WIN' : '‚ùå LOSS', 80, y);
                
                // Map name with icon
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.fillText(`üó∫Ô∏è ${match.metadata.map.name}`, 160, y);
                
                // Agent name
                ctx.fillText(`üë§ ${player.agent.name}`, 320, y);
                
                // Enhanced KDA display
                const kda = `${player.stats.kills}/${player.stats.deaths}/${player.stats.assists}`;
                const kdRatio = player.stats.deaths > 0 ? (player.stats.kills / player.stats.deaths).toFixed(2) : player.stats.kills.toFixed(2);
                ctx.fillText(`‚öîÔ∏è ${kda} (${kdRatio} K/D)`, 450, y);
                
                // Score with color coding
                const acs = player.stats.score;
                ctx.fillStyle = acs >= 250 ? '#00ff88' : acs >= 200 ? '#ffff00' : acs >= 150 ? '#ff8800' : '#ff4444';
                ctx.fillText(`üìà ${acs} ACS`, 600, y);
                
                // Date
                const matchDate = new Date(match.metadata.started_at);
                ctx.fillStyle = '#cccccc';
                ctx.fillText(`üìÖ ${matchDate.toLocaleDateString()}`, 720, y);
                
                // Enhanced headshot percentage
                const totalShots = player.stats.headshots + player.stats.bodyshots + player.stats.legshots;
                const hsPercent = totalShots > 0 ? Math.round((player.stats.headshots / totalShots) * 100) : 0;
                ctx.fillStyle = hsPercent >= 30 ? '#00ff88' : hsPercent >= 20 ? '#ffff00' : '#ff8800';
                ctx.fillText(`üéØ ${hsPercent}%`, 820, y);
            });
        } else {
            // No competitive matches found
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('üìä NO RECENT COMPETITIVE MATCHES FOUND', 80, 420);
            
            ctx.font = '16px Arial';
            ctx.fillStyle = '#cccccc';
            ctx.fillText('Play some competitive matches to see your recent performance here!', 80, 450);
        }
    }
    
    // Enhanced footer with version info
    ctx.fillStyle = '#666666';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Powered by HenrikDev Valorant API ‚Ä¢ Enhanced Visual Stats v3.0 ‚Ä¢ KDA + Stored Matches Integration', 500, 780);
    
    return canvas;
}

// Helper function to safely respond to interactions
async function safeInteractionResponse(interaction, responseType, responseData) {
    try {
        // Check if interaction is still valid (not expired)
        if (!interaction.isRepliable()) {
            console.log('Interaction is no longer repliable');
            return false;
        }

        // Check which response method to use
        if (responseType === 'reply') {
            if (interaction.replied || interaction.deferred) {
                await interaction.followUp(responseData);
            } else {
                await interaction.reply(responseData);
            }
        } else if (responseType === 'update') {
            if (interaction.replied) {
                await interaction.editReply(responseData);
            } else {
                await interaction.update(responseData);
            }
        } else if (responseType === 'defer') {
            if (!interaction.deferred && !interaction.replied) {
                await interaction.deferUpdate();
            }
        }
        return true;
    } catch (error) {
        console.error('Error in safe interaction response:', error.message);
        
        // Try fallback response if possible
        try {
            if (!interaction.replied && !interaction.deferred && responseType === 'reply') {
                await interaction.reply({ 
                    content: '‚ùå There was an error processing your request. Please try again.', 
                    ephemeral: true 
                });
            }
        } catch (fallbackError) {
            console.error('Fallback response also failed:', fallbackError.message);
        }
        return false;
    }
}

// Load existing registrations on startup
loadUserRegistrations();

// Export API handler functions and event handlers separately
module.exports = {
    // Data functions
    getUserRegistration,
    getUserRankData,
    loadRankImage,
    RANK_MAPPING,
    createFallbackRankIcon,
    getAllRegisteredUsers,
    
    // Initialize function to set up event handlers
    init: (client) => {
        // Only add event listeners if not already added
        if (!client._valorantApiHandlerInitialized) {
            console.log('Valorant API Handler with KDA Integration & Stored Matches loaded successfully!');
            console.log(`Registered regions: ${VALID_REGIONS.join(', ')}`);
            console.log('Commands: !valstats, !valprofile, !valmatches, !createteams (admin), !valtest (admin), !valreset (admin), !vallist (admin), !valskills (admin)');
            console.log(`Data file: ${USERS_FILE}`);
            console.log(`Loaded ${userRegistrations.size} registered users`);

            client.on('messageCreate', async (message) => {
                if (message.author.bot) return;
                if (!message.guild) return;

                const args = message.content.split(' ');
                const command = args[0].toLowerCase();

                // Stats commands
                if (command === '!valstats' || command === '!valprofile') {
                    const userId = message.author.id;
                    const registration = userRegistrations.get(userId);

                    if (!registration) {
                        await showRegistrationPrompt(message);
                    } else {
                        await showUserStats(message, registration);
                    }
                }

                // New matches command
                if (command === '!valmatches') {
                    const userId = message.author.id;
                    const registration = userRegistrations.get(userId);

                    if (!registration) {
                        await showRegistrationPrompt(message);
                    } else {
                        await showUserMatches(message, registration);
                    }
                }

                // Admin commands
                if (command === '!valreset' && message.member.permissions.has('ADMINISTRATOR')) {
                    const targetUser = message.mentions.users.first();
                    if (targetUser) {
                        if (removeUserRegistration(targetUser.id)) {
                            message.reply(`‚úÖ Reset Valorant registration for ${targetUser.username}`);
                        } else {
                            message.reply(`‚ùå ${targetUser.username} was not registered`);
                        }
                    }
                }

                // Enhanced team creation command with better error handling
                if (command === '!createteams' && message.member.permissions.has('ADMINISTRATOR')) {
                    const messageId = args[1];
                    const channelId = args[2]; // Optional channel ID
                    
                    if (!messageId) {
                        return message.reply({
                            embeds: [new EmbedBuilder()
                                .setTitle('‚ùå Missing Message ID')
                                .setColor('#ff0000')
                                .setDescription('Please provide a message ID to create teams from.')
                                .addFields(
                                    { 
                                        name: 'üìñ Usage', 
                                        value: '`!createteams <messageId> [channelId]`\n\n**Examples:**\n‚Ä¢ `!createteams 1234567890` (same channel)\n‚Ä¢ `!createteams 1234567890 9876543210` (different channel)', 
                                        inline: false 
                                    },
                                    { 
                                        name: 'üí° How to get Message ID', 
                                        value: '1. Enable Developer Mode in Discord settings\n2. Right-click the message with reactions\n3. Select "Copy Message ID"', 
                                        inline: false 
                                    }
                                )
                                .setTimestamp()]
                        });
                    }
                    await handleCreateTeams(message, messageId, channelId);
                }

                if (command === '!vallist' && message.member.permissions.has('ADMINISTRATOR')) {
                    const allUsers = getAllRegisteredUsers();
                    if (allUsers.length === 0) {
                        return message.reply('üìã No users are currently registered.');
                    }

                    const embed = new EmbedBuilder()
                        .setTitle('üìã Registered Valorant Users')
                        .setColor('#ff4654')
                        .setDescription(`Total registered users: **${allUsers.length}**`)
                        .setTimestamp();

                    const userList = allUsers.map((user, index) => {
                        const discordUser = client.users.cache.get(user.discordId);
                        const discordName = discordUser ? discordUser.username : 'Unknown User';
                        return `${index + 1}. **${user.name}#${user.tag}** (${user.region.toUpperCase()}) - ${discordName}`;
                    }).join('\n');

                    embed.addFields({
                        name: 'üë• Users',
                        value: userList.length > 1024 ? userList.substring(0, 1021) + '...' : userList,
                        inline: false
                    });

                    message.reply({ embeds: [embed] });
                }

                if (command === '!valskills' && message.member.permissions.has('ADMINISTRATOR')) {
                    const allUsers = getAllRegisteredUsers();
                    if (allUsers.length === 0) {
                        return message.reply('üìã No users are currently registered.');
                    }

                    const loadingEmbed = new EmbedBuilder()
                        .setTitle('üîÑ Calculating Skill Ratings...')
                        .setColor('#ff4654')
                        .setDescription('Fetching comprehensive stats for all registered users...')
                        .setTimestamp();

                    const loadingMessage = await message.channel.send({ embeds: [loadingEmbed] });

                    try {
                        const playersWithSkills = [];
                        
                        for (const userData of allUsers) {
                            try {
                                const registration = {
                                    name: userData.name,
                                    tag: userData.tag,
                                    region: userData.region,
                                    puuid: userData.puuid
                                };

                                // Get current rank data
                                const rankData = await getUserRankData(userData.discordId);
                                
                                // Get match statistics with KDA data
                                const matchStats = await getPlayerMatchStats(registration);

                                // Get peak rank from MMR data
                                const mmrData = await makeAPIRequest(
                                    `/v2/mmr/${registration.region}/${encodeURIComponent(registration.name)}/${encodeURIComponent(registration.tag)}`
                                );
                                
                                let peakTier = 0;
                                if (mmrData.status === 200 && mmrData.data.highest_rank) {
                                    peakTier = mmrData.data.highest_rank.tier;
                                }

                                const currentTier = rankData ? rankData.currenttier : 0;
                                const currentRR = rankData ? rankData.ranking_in_tier : 0;

                                // Calculate skill score
                                const skillScore = calculateEnhancedSkillScore(
                                    currentTier, 
                                    peakTier, 
                                    matchStats.winRate, 
                                    currentRR, 
                                    matchStats.avgKDA,
                                    matchStats.avgACS
                                );

                                const discordUser = client.users.cache.get(userData.discordId);
                                const discordName = discordUser ? discordUser.username : 'Unknown User';

                                playersWithSkills.push({
                                    discordName,
                                    valorantName: `${userData.name}#${userData.tag}`,
                                    currentRank: RANK_MAPPING[currentTier] || RANK_MAPPING[0],
                                    currentRR,
                                    peakRank: RANK_MAPPING[peakTier] || RANK_MAPPING[0],
                                    avgKDA: matchStats.avgKDA,
                                    winRate: matchStats.winRate,
                                    matchesPlayed: matchStats.totalMatches,
                                    skillScore
                                });

                            } catch (error) {
                                console.error(`Error calculating skill for ${userData.name}#${userData.tag}:`, error);
                                // Continue with next user
                            }
                        }

                        if (playersWithSkills.length === 0) {
                            const errorEmbed = new EmbedBuilder()
                                .setTitle('‚ùå No Skill Data Available')
                                .setColor('#ff0000')
                                .setDescription('Could not calculate skill ratings for any registered users.')
                                .setTimestamp();
                            
                            return await loadingMessage.edit({ embeds: [errorEmbed] });
                        }

                        // Sort by skill score (highest to lowest)
                        playersWithSkills.sort((a, b) => b.skillScore - a.skillScore);

                        const skillEmbed = new EmbedBuilder()
                            .setTitle('üéØ Player Skill Ratings (Admin Only)')
                            .setColor('#ff4654')
                            .setDescription(`Comprehensive skill analysis for ${playersWithSkills.length} players`)
                            .addFields({
                                name: 'üßÆ Skill Formula',
                                value: 'Current Rank (35%) + KDA (25%) + Win Rate (20%) + Peak Rank (15%) + RR (5%)',
                                inline: false
                            })
                            .setTimestamp();

                        let skillList = '';
                        playersWithSkills.forEach((player, index) => {
                            const rankText = player.currentRR > 0 ? `${player.currentRank.name} (${player.currentRR} RR)` : player.currentRank.name;
                            const kdaText = player.avgKDA > 0 ? player.avgKDA.toFixed(2) : 'N/A';
                            const wrText = player.winRate > 0 ? `${player.winRate.toFixed(0)}%` : 'N/A';
                            const matchesText = player.matchesPlayed > 0 ? ` (${player.matchesPlayed} matches)` : '';
                            
                            skillList += `**${index + 1}.** ${player.discordName}\n`;
                            skillList += `‚îî ${player.valorantName}\n`;
                            skillList += `‚îî ${rankText} ‚Ä¢ Peak: ${player.peakRank.name}\n`;
                            skillList += `‚îî KDA: ${kdaText} ‚Ä¢ WR: ${wrText}${matchesText}\n`;
                            skillList += `‚îî **Skill Score: ${player.skillScore.toFixed(2)}**\n\n`;
                        });

                        // Split into multiple fields if needed
                        const maxLength = 1024;
                        if (skillList.length <= maxLength) {
                            skillEmbed.addFields({
                                name: 'üìä Player Rankings',
                                value: skillList,
                                inline: false
                            });
                        } else {
                            // Split into multiple fields
                            const chunks = [];
                            let currentChunk = '';
                            const lines = skillList.split('\n');
                            
                            for (const line of lines) {
                                if ((currentChunk + line + '\n').length > maxLength) {
                                    if (currentChunk) chunks.push(currentChunk);
                                    currentChunk = line + '\n';
                                } else {
                                    currentChunk += line + '\n';
                                }
                            }
                            if (currentChunk) chunks.push(currentChunk);

                            chunks.forEach((chunk, index) => {
                                skillEmbed.addFields({
                                    name: index === 0 ? 'üìä Player Rankings' : 'üìä Player Rankings (cont.)',
                                    value: chunk,
                                    inline: false
                                });
                            });
                        }

                        await loadingMessage.edit({ embeds: [skillEmbed] });

                    } catch (error) {
                        console.error('Error calculating skill ratings:', error);
                        
                        const errorEmbed = new EmbedBuilder()
                            .setTitle('‚ùå Error Calculating Skill Ratings')
                            .setColor('#ff0000')
                            .setDescription('There was an error calculating skill ratings.')
                            .addFields(
                                { name: 'üêõ Error Details:', value: `\`${error.message}\``, inline: false }
                            )
                            .setTimestamp();

                        await loadingMessage.edit({ embeds: [errorEmbed] });
                    }
                }

                if (command === '!valtest' && message.member.permissions.has('ADMINISTRATOR')) {
                    const testEmbed = new EmbedBuilder()
                        .setTitle('üîß Testing Valorant API...')
                        .setColor('#ff4654')
                        .setDescription('Testing connection to HenrikDev API...')
                        .setTimestamp();

                    const testMessage = await message.channel.send({ embeds: [testEmbed] });

                    try {
                        const testData = await makeAPIRequest('/v1/account/Riot/123');
                        
                        const resultEmbed = new EmbedBuilder()
                            .setTitle('‚úÖ API Test Results')
                            .setColor('#00ff00')
                            .addFields(
                                { name: 'Status', value: testData.status ? testData.status.toString() : 'No status', inline: true },
                                { name: 'Data File', value: fs.existsSync(USERS_FILE) ? '‚úÖ Exists' : '‚ùå Missing', inline: true },
                                { name: 'Registered Users', value: userRegistrations.size.toString(), inline: true },
                                { name: 'Response', value: `\`\`\`json\n${JSON.stringify(testData, null, 2).substring(0, 1000)}\n\`\`\``, inline: false }
                            )
                            .setTimestamp();

                        await testMessage.edit({ embeds: [resultEmbed] });
                    } catch (error) {
                        const errorEmbed = new EmbedBuilder()
                            .setTitle('‚ùå API Test Failed')
                            .setColor('#ff0000')
                            .addFields(
                                { name: 'Error', value: error.message, inline: false },
                                { name: 'Data File', value: fs.existsSync(USERS_FILE) ? '‚úÖ Exists' : '‚ùå Missing', inline: true },
                                { name: 'Registered Users', value: userRegistrations.size.toString(), inline: true },
                                { name: 'Full Error', value: `\`\`\`\n${error.stack.substring(0, 1000)}\n\`\`\``, inline: false }
                            )
                            .setTimestamp();

                        await testMessage.edit({ embeds: [errorEmbed] });
                    }
                }
            });

            client.on('interactionCreate', async (interaction) => {
                if (interaction.isButton()) {
                    if (interaction.customId.startsWith('valstats_register_')) {
                        const userId = interaction.customId.split('_')[2];
                        if (interaction.user.id !== userId) {
                            return safeInteractionResponse(interaction, 'reply', {
                                content: '‚ùå This registration is not for you!',
                                ephemeral: true
                            });
                        }
                        await showRegistrationModal(interaction);
                    }

                    if (interaction.customId.startsWith('valstats_refresh_')) {
                        const userId = interaction.customId.split('_')[2];
                        if (interaction.user.id !== userId) {
                            return safeInteractionResponse(interaction, 'reply', {
                                content: '‚ùå This is not your stats panel!',
                                ephemeral: true
                            });
                        }

                        const registration = userRegistrations.get(userId);
                        if (!registration) {
                            return safeInteractionResponse(interaction, 'reply', {
                                content: '‚ùå You are not registered! Use `!valstats` to register.',
                                ephemeral: true
                            });
                        }

                        await safeInteractionResponse(interaction, 'defer');
                        await showUserStats({ 
                            channel: interaction.channel, 
                            author: interaction.user 
                        }, registration);
                    }

                    if (interaction.customId.startsWith('valmatches_refresh_')) {
                        const userId = interaction.customId.split('_')[2];
                        if (interaction.user.id !== userId) {
                            return safeInteractionResponse(interaction, 'reply', {
                                content: '‚ùå This is not your matches panel!',
                                ephemeral: true
                            });
                        }

                        const registration = userRegistrations.get(userId);
                        if (!registration) {
                            return safeInteractionResponse(interaction, 'reply', {
                                content: '‚ùå You are not registered! Use `!valstats` to register.',
                                ephemeral: true
                            });
                        }

                        await safeInteractionResponse(interaction, 'defer');
                        await showUserMatches({ 
                            channel: interaction.channel, 
                            author: interaction.user 
                        }, registration);
                    }

                    if (interaction.customId.startsWith('valstats_details_')) {
                        const userId = interaction.customId.split('_')[2];
                        if (interaction.user.id !== userId) {
                            return safeInteractionResponse(interaction, 'reply', {
                                content: '‚ùå This is not your stats panel!',
                                ephemeral: true
                            });
                        }

                        return safeInteractionResponse(interaction, 'reply', {
                            content: 'üöß Detailed match view coming soon! For now, check your recent matches in the stats image above.',
                            ephemeral: true
                        });
                    }
                }

                if (interaction.isModalSubmit()) {
                    if (interaction.customId.startsWith('valstats_registration_')) {
                        await handleRegistrationSubmission(interaction);
                    }
                }
            });

            client._valorantApiHandlerInitialized = true;
        }

        // Enhanced Team Creation Functions with KDA integration
        async function handleCreateTeams(message, messageId, channelId = null) {
            const loadingEmbed = new EmbedBuilder()
                .setTitle('üîÑ Creating Balanced Teams...')
                .setColor('#ff4654')
                .setDescription('Analyzing player reactions and calculating comprehensive team balance...')
                .setTimestamp();

            const loadingMessage = await message.channel.send({ embeds: [loadingEmbed] });

            try {
                // Determine which channel to search in
                let targetChannel = message.channel;
                if (channelId) {
                    try {
                        targetChannel = await client.channels.fetch(channelId);
                        if (!targetChannel) {
                            throw new Error('Channel not found');
                        }
                        if (!targetChannel.isTextBased()) {
                            throw new Error('Target channel is not a text channel');
                        }
                    } catch (error) {
                        throw new Error(`Could not access channel ${channelId}: ${error.message}`);
                    }
                }

                // Validate message ID format
                if (!/^\d{17,19}$/.test(messageId)) {
                    throw new Error('Invalid message ID format. Message IDs should be 17-19 digits long.');
                }

                // Attempt to fetch the target message with better error handling
                let targetMessage;
                try {
                    targetMessage = await targetChannel.messages.fetch(messageId);
                    if (!targetMessage) {
                        throw new Error('Message not found');
                    }
                } catch (fetchError) {
                    if (fetchError.code === 10008) {
                        throw new Error(`Message with ID ${messageId} was not found in ${targetChannel.name}. Please check:\n‚Ä¢ The message ID is correct\n‚Ä¢ The message exists in the specified channel\n‚Ä¢ The message hasn't been deleted\n‚Ä¢ The bot has permission to read message history`);
                    } else if (fetchError.code === 50001) {
                        throw new Error(`The bot doesn't have permission to access ${targetChannel.name}`);
                    } else if (fetchError.code === 50013) {
                        throw new Error(`The bot doesn't have permission to read message history in ${targetChannel.name}`);
                    } else {
                        throw new Error(`Failed to fetch message: ${fetchError.message}`);
                    }
                }

                // Check if the message has any reactions
                if (!targetMessage.reactions.cache.size) {
                    throw new Error('The target message has no reactions. Players need to react to the message to be included in team creation.');
                }

                // Get all users who reacted to the message
                const reactors = await getMessageReactors(targetMessage);
                
                if (reactors.length < 2) {
                    throw new Error(`Need at least 2 players to create teams. Found ${reactors.length} reactor(s).`);
                }

                // Update loading message with progress
                const progressEmbed = new EmbedBuilder()
                    .setTitle('üîÑ Processing Players...')
                    .setColor('#ff4654')
                    .setDescription(`Found ${reactors.length} players. Getting comprehensive Valorant stats...`)
                    .addFields({
                        name: 'üìä Progress',
                        value: 'Fetching player registrations, rank data, and match statistics...',
                        inline: false
                    })
                    .setTimestamp();

                await loadingMessage.edit({ embeds: [progressEmbed] });

                // Get comprehensive stats for each registered player
                const players = await getPlayersWithStats(reactors, client);
                
                if (players.length < 2) {
                    const unregisteredCount = reactors.length - players.length;
                    throw new Error(`Need at least 2 registered players to create teams. Found ${players.length} registered player(s) out of ${reactors.length} total reactors.\n\n${unregisteredCount > 0 ? `${unregisteredCount} player(s) need to register using \`!valstats\`.` : ''}`);
                }

                // Update loading with calculation phase
                const calcEmbed = new EmbedBuilder()
                    .setTitle('‚öñÔ∏è Calculating Team Balance...')
                    .setColor('#ff4654')
                    .setDescription(`Analyzing ${players.length} players using enhanced skill formula...`)
                    .addFields({
                        name: 'üßÆ Skill Formula Components',
                        value: '‚Ä¢ Current Rank (35%)\n‚Ä¢ KDA Ratio (25%)\n‚Ä¢ Win Rate (20%)\n‚Ä¢ Peak Rank (15%)\n‚Ä¢ Current RR (5%)',
                        inline: false
                    })
                    .setTimestamp();

                await loadingMessage.edit({ embeds: [calcEmbed] });

                // Create balanced teams
                const teams = createBalancedTeams(players);

                // Display the teams
                await displayBalancedTeams(loadingMessage, teams, reactors.length, players.length, targetChannel.name);

            } catch (error) {
                console.error('Error creating teams:', error);
                
                const errorEmbed = new EmbedBuilder()
                    .setTitle('‚ùå Error Creating Teams')
                    .setColor('#ff0000')
                    .setDescription('There was an error creating balanced teams.')
                    .addFields(
                        { 
                            name: 'üêõ Error Details:', 
                            value: `\`\`\`${error.message}\`\`\``, 
                            inline: false 
                        },
                        { 
                            name: 'üí° Common Solutions:', 
                            value: [
                                '‚Ä¢ Double-check the message ID is correct',
                                '‚Ä¢ Ensure the message has reactions',
                                '‚Ä¢ Make sure players are registered with `!valstats`',
                                '‚Ä¢ Verify the bot has permission to read message history',
                                '‚Ä¢ If using a different channel, include the channel ID: `!createteams <messageId> <channelId>`'
                            ].join('\n'), 
                            inline: false 
                        },
                        { 
                            name: 'üìñ Command Format:', 
                            value: '`!createteams <messageId> [channelId]`', 
                            inline: false 
                        }
                    )
                    .setTimestamp();

                await loadingMessage.edit({ embeds: [errorEmbed] });
            }
        }

        async function getMessageReactors(targetMessage) {
            const reactors = new Set();
            
            // Get all reactions from the message
            for (const reaction of targetMessage.reactions.cache.values()) {
                try {
                    const users = await reaction.users.fetch();
                    users.forEach(user => {
                        if (!user.bot) { // Exclude bots
                            reactors.add(user);
                        }
                    });
                } catch (error) {
                    console.error('Error fetching reaction users:', error);
                }
            }

            return Array.from(reactors);
        }

        async function getPlayersWithStats(reactors, client) {
            const players = [];
            
            for (const user of reactors) {
                try {
                    const registration = userRegistrations.get(user.id);
                    if (!registration) {
                        console.log(`User ${user.username} is not registered`);
                        continue;
                    }

                    console.log(`Getting comprehensive stats for ${registration.name}#${registration.tag}...`);

                    // Get current rank data
                    const rankData = await getUserRankData(user.id);
                    
                    // Get match statistics with KDA data using enhanced function
                    const matchStats = await getPlayerMatchStats(registration);

                    // Get peak rank from MMR data
                    const mmrData = await makeAPIRequest(
                        `/v2/mmr/${registration.region}/${encodeURIComponent(registration.name)}/${encodeURIComponent(registration.tag)}`
                    );
                    
                    let peakTier = 0;
                    if (mmrData.status === 200 && mmrData.data.highest_rank) {
                        peakTier = mmrData.data.highest_rank.tier;
                    }

                    const currentTier = rankData ? rankData.currenttier : 0;
                    const currentRR = rankData ? rankData.ranking_in_tier : 0;

                    // Calculate enhanced skill score with KDA
                    const skillScore = calculateEnhancedSkillScore(
                        currentTier, 
                        peakTier, 
                        matchStats.winRate, 
                        currentRR, 
                        matchStats.avgKDA,
                        matchStats.avgACS
                    );

                    players.push({
                        user: user,
                        registration: registration,
                        currentTier: currentTier,
                        currentRR: currentRR,
                        peakTier: peakTier,
                        winRate: matchStats.winRate,
                        avgKDA: matchStats.avgKDA,
                        avgACS: matchStats.avgACS,
                        matchesPlayed: matchStats.totalMatches,
                        skillScore: skillScore,
                        rankInfo: RANK_MAPPING[currentTier] || RANK_MAPPING[0],
                        peakRankInfo: RANK_MAPPING[peakTier] || RANK_MAPPING[0]
                    });

                } catch (error) {
                    console.error(`Error getting stats for ${user.username}:`, error);
                    // Continue with next player
                }
            }

            return players;
        }

        // Enhanced skill score calculation with KDA integration
        function calculateEnhancedSkillScore(currentTier, peakTier, winRate, currentRR, avgKDA, avgACS) {
            // Enhanced skill score formula with KDA integration
            // Current tier: 35% weight (still most important)
            // KDA: 25% weight (significant impact on individual skill)
            // Win rate: 20% weight 
            // Peak tier: 15% weight
            // Current RR: 5% weight
            
            const currentScore = currentTier * 0.35;
            
            // KDA score: normalize to similar scale as ranks (0-27)
            // Good KDA is around 1.0-1.5, excellent is 2.0+
            const kdaScore = Math.min(avgKDA * 8, 27) * 0.25; // Cap at 27 equivalent points
            
            const winRateScore = (winRate / 100) * 8 * 0.20; // Normalize win rate to similar scale
            const peakScore = peakTier * 0.15;
            const rrScore = (currentRR / 100) * 0.05; // RR contributes least
            
            const totalScore = currentScore + kdaScore + winRateScore + peakScore + rrScore;
            
            console.log(`Skill calculation for player: Current(${currentTier}*0.35=${currentScore.toFixed(2)}) + KDA(${avgKDA.toFixed(2)}*8*0.25=${kdaScore.toFixed(2)}) + WR(${winRate.toFixed(1)}%*0.20=${winRateScore.toFixed(2)}) + Peak(${peakTier}*0.15=${peakScore.toFixed(2)}) + RR(${currentRR}*0.05=${rrScore.toFixed(2)}) = ${totalScore.toFixed(2)}`);
            
            return totalScore;
        }

        function createBalancedTeams(players) {
            // Sort players by skill score (highest to lowest)
            players.sort((a, b) => b.skillScore - a.skillScore);
            
            // Determine number of teams (try for teams of 5, minimum 2 teams)
            const numPlayers = players.length;
            let numTeams = Math.max(2, Math.floor(numPlayers / 5));
            
            // If we have exactly 10 players, make 2 teams of 5
            if (numPlayers === 10) {
                numTeams = 2;
            }
            // If we have 6-9 players, make 2 teams
            else if (numPlayers >= 6 && numPlayers <= 9) {
                numTeams = 2;
            }
            // If we have 11-15 players, make 3 teams
            else if (numPlayers >= 11 && numPlayers <= 15) {
                numTeams = 3;
            }
            
            // Initialize teams
            const teams = Array.from({ length: numTeams }, () => ({
                players: [],
                totalSkill: 0,
                avgSkill: 0,
                totalKDA: 0,
                avgKDA: 0,
                avgWinRate: 0
            }));
            
            // Use snake draft algorithm for better balance
            let teamIndex = 0;
            let direction = 1;
            
            for (let i = 0; i < players.length; i++) {
                teams[teamIndex].players.push(players[i]);
                teams[teamIndex].totalSkill += players[i].skillScore;
                teams[teamIndex].totalKDA += players[i].avgKDA;
                
                // Calculate team averages
                const teamSize = teams[teamIndex].players.length;
                teams[teamIndex].avgSkill = teams[teamIndex].totalSkill / teamSize;
                teams[teamIndex].avgKDA = teams[teamIndex].totalKDA / teamSize;
                teams[teamIndex].avgWinRate = teams[teamIndex].players.reduce((sum, p) => sum + p.winRate, 0) / teamSize;
                
                // Snake draft: 0,1,2,2,1,0,0,1,2,2,1,0...
                if (direction === 1) {
                    teamIndex++;
                    if (teamIndex >= numTeams) {
                        teamIndex = numTeams - 1;
                        direction = -1;
                    }
                } else {
                    teamIndex--;
                    if (teamIndex < 0) {
                        teamIndex = 0;
                        direction = 1;
                    }
                }
            }
            
            return teams;
        }

        async function displayBalancedTeams(loadingMessage, teams, totalReactors, registeredPlayers, channelName = 'current channel') {
            const embed = new EmbedBuilder()
                .setTitle('‚öñÔ∏è Enhanced Balanced Valorant Teams')
                .setColor('#ff4654')
                .setDescription(`Created ${teams.length} balanced teams from reactions in ${channelName}`)
                .addFields(
                    { 
                        name: 'üìä Analysis Summary', 
                        value: `**Total Reactors:** ${totalReactors}\n**Registered Players:** ${registeredPlayers}\n**Teams Created:** ${teams.length}\n**Algorithm:** Enhanced Snake Draft with KDA`, 
                        inline: false 
                    }
                )
                .setTimestamp();

            // Add each team with enhanced stats
            teams.forEach((team, index) => {
                const teamNumber = index + 1;
                const teamEmoji = ['üî¥', 'üîµ', 'üü¢', 'üü°', 'üü£', 'üü†'][index] || '‚ö™';
                
                let teamInfo = '';
                team.players.forEach((player, playerIndex) => {
                    const rankName = player.rankInfo.name;
                    const rrText = player.currentRR > 0 ? ` (${player.currentRR} RR)` : '';
                    const kdaText = player.avgKDA > 0 ? ` ‚Ä¢ KDA: ${player.avgKDA.toFixed(2)}` : '';
                    const winRateText = player.winRate > 0 ? ` ‚Ä¢ ${player.winRate.toFixed(0)}% WR` : '';
                    const acsText = player.avgACS > 0 ? ` ‚Ä¢ ${Math.round(player.avgACS)} ACS` : '';
                    
                    teamInfo += `${playerIndex + 1}. **${player.user.displayName || player.user.username}**\n`;
                    teamInfo += `‚îî ${rankName}${rrText}${kdaText}${winRateText}\n`;
                    teamInfo += `‚îî Peak: ${player.peakRankInfo.name}${acsText}\n\n`;
                });

                embed.addFields({
                    name: `${teamEmoji} Team ${teamNumber} (KDA: ${team.avgKDA.toFixed(2)} ‚Ä¢ WR: ${team.avgWinRate.toFixed(0)}%)`,
                    value: teamInfo || 'No players',
                    inline: true
                });
            });

            // Add unregistered players if any
            const unregisteredCount = totalReactors - registeredPlayers;
            if (unregisteredCount > 0) {
                embed.addFields({
                    name: '‚ö†Ô∏è Unregistered Players',
                    value: `${unregisteredCount} players who reacted are not registered.\nThey can use \`!valstats\` to register and be included in future team creation.`,
                    inline: false
                });
            }

            // Enhanced balance information with KDA metrics (skill difference hidden from display)
            const skillScores = teams.map(team => team.avgSkill);
            const kdaScores = teams.map(team => team.avgKDA);
            const minSkill = Math.min(...skillScores);
            const maxSkill = Math.max(...skillScores);
            const skillDifference = maxSkill - minSkill;
            const avgKDADiff = Math.max(...kdaScores) - Math.min(...kdaScores);
            
            const balanceColor = skillDifference < 1 ? 'üü¢' : skillDifference < 2 ? 'üü°' : 'üî¥';
            embed.addFields({
                name: `${balanceColor} Team Balance Analysis`,
                value: `**KDA Difference:** ${avgKDADiff.toFixed(2)}\n` +
                       `${skillDifference < 1 ? 'Excellent balance!' : skillDifference < 2 ? 'Good balance' : 'Teams may be unbalanced'}\n` +
                       `*Internal skill scores used for balancing*`,
                inline: false
            });

            embed.setFooter({ 
                text: 'Balanced using: Current Rank (35%) + KDA (25%) + Win Rate (20%) + Peak Rank (15%) + RR (5%) ‚Ä¢ Use !valskills (admin) to view ratings' 
            });

            await loadingMessage.edit({ embeds: [embed] });
        }

        async function showRegistrationPrompt(message) {
            const embed = new EmbedBuilder()
                .setTitle('üîê Valorant Registration Required')
                .setColor('#ff4654')
                .setDescription('You need to register your Valorant account to use this feature!')
                .addFields(
                    { name: 'üìù What we need:', value: '‚Ä¢ Your Valorant username and tag (e.g., Player#1234)\n‚Ä¢ Your region (e.g., na, eu, ap)', inline: false },
                    { name: 'üîí Privacy:', value: 'Your data is stored securely in our local database file. No personal Discord data is saved.', inline: false },
                    { name: 'üåç Valid Regions:', value: VALID_REGIONS.join(', ').toUpperCase(), inline: false },
                    { name: 'üéØ Team Builder Integration:', value: 'Once registered, your rank and KDA will show in team builder!', inline: false },
                    { name: 'üíæ Persistent Storage:', value: 'Your registration will persist even if the bot restarts!', inline: false },
                    { name: 'üìä Enhanced Stats:', value: 'Now includes comprehensive KDA analysis from stored matches!', inline: false }
                )
                .setFooter({ text: 'Click the button below to register!' })
                .setTimestamp();

            const registerButton = new ButtonBuilder()
                .setCustomId(`valstats_register_${message.author.id}`)
                .setLabel('Register Now')
                .setStyle(ButtonStyle.Primary)
                .setEmoji('üìù');

            const row = new ActionRowBuilder().addComponents(registerButton);
            return message.channel.send({ embeds: [embed], components: [row] });
        }

        async function showRegistrationModal(interaction) {
            const modal = new ModalBuilder()
                .setCustomId(`valstats_registration_${interaction.user.id}`)
                .setTitle('üéØ Valorant Account Registration');

            const usernameInput = new TextInputBuilder()
                .setCustomId('valorant_username')
                .setLabel('Valorant Username and Tag')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('e.g., PlayerName#1234')
                .setRequired(true)
                .setMaxLength(50);

            const regionInput = new TextInputBuilder()
                .setCustomId('valorant_region')
                .setLabel('Region')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('e.g., na, eu, ap, kr, latam, br')
                .setRequired(true)
                .setMaxLength(10);

            const firstRow = new ActionRowBuilder().addComponents(usernameInput);
            const secondRow = new ActionRowBuilder().addComponents(regionInput);

            modal.addComponents(firstRow, secondRow);
            await interaction.showModal(modal);
        }

        async function handleRegistrationSubmission(interaction) {
            const username = interaction.fields.getTextInputValue('valorant_username');
            const region = interaction.fields.getTextInputValue('valorant_region').toLowerCase();

            if (!username.includes('#') || username.split('#').length !== 2) {
                return safeInteractionResponse(interaction, 'reply', {
                    content: '‚ùå Invalid username format! Please use the format: Username#Tag (e.g., Player#1234)',
                    ephemeral: true
                });
            }

            if (!VALID_REGIONS.includes(region)) {
                return safeInteractionResponse(interaction, 'reply', {
                    content: `‚ùå Invalid region! Valid regions are: ${VALID_REGIONS.join(', ').toUpperCase()}`,
                    ephemeral: true
                });
            }

            const [name, tag] = username.split('#');
            await safeInteractionResponse(interaction, 'defer', { ephemeral: true });

            try {
                console.log(`Testing account: ${name}#${tag} in region ${region}`);
                const accountData = await makeAPIRequest(`/v1/account/${encodeURIComponent(name)}/${encodeURIComponent(tag)}`);
                
                if (accountData.status !== 200) {
                    return safeInteractionResponse(interaction, 'reply', {
                        content: `‚ùå Could not find a Valorant account with that username and tag. Please check your spelling and try again.\n\nAPI Response: ${accountData.error || 'Unknown error'}`
                    });
                }

                const userData = {
                    name: name,
                    tag: tag,
                    region: region,
                    puuid: accountData.data.puuid,
                    registeredAt: new Date().toISOString()
                };

                addUserRegistration(interaction.user.id, userData);

                const successEmbed = new EmbedBuilder()
                    .setTitle('‚úÖ Registration Successful!')
                    .setColor('#00ff00')
                    .setDescription(`Successfully registered your Valorant account: **${name}#${tag}**`)
                    .addFields(
                        { name: 'üåç Region', value: region.toUpperCase(), inline: true },
                        { name: '‚≠ê Level', value: accountData.data.account_level.toString(), inline: true },
                        { name: 'üíæ Storage', value: 'Saved to persistent database', inline: true },
                        { name: 'üöÄ Next Step', value: 'Use `!valstats` or `!valprofile` to view your stats!', inline: false },
                        { name: 'üéØ Team Builder', value: 'Your rank and KDA will now show when you join Valorant teams!', inline: false },
                        { name: 'üìä Enhanced Features', value: 'Comprehensive match analysis with stored matches API integration!', inline: false }
                    )
                    .setTimestamp();

                await safeInteractionResponse(interaction, 'reply', { embeds: [successEmbed] });

            } catch (error) {
                console.error('Registration error:', error);
                await safeInteractionResponse(interaction, 'reply', {
                    content: '‚ùå There was an error validating your account. Please try again later or contact an administrator.\n\nError: ' + error.message
                });
            }
        }

        async function showUserStats(message, registration) {
            const loadingEmbed = new EmbedBuilder()
                .setTitle('üîÑ Loading Enhanced Valorant Stats...')
                .setColor('#ff4654')
                .setDescription('Fetching your latest data from Riot Games with comprehensive analysis...')
                .setTimestamp();

            const loadingMessage = await message.channel.send({ embeds: [loadingEmbed] });

            try {
                console.log(`Fetching enhanced stats for: ${registration.name}#${registration.tag} in ${registration.region}`);
                
                const [accountData, mmrData, matchData] = await Promise.all([
                    makeAPIRequest(`/v1/account/${encodeURIComponent(registration.name)}/${encodeURIComponent(registration.tag)}`),
                    makeAPIRequest(`/v2/mmr/${registration.region}/${encodeURIComponent(registration.name)}/${encodeURIComponent(registration.tag)}`),
                    makeAPIRequest(`/v4/matches/${registration.region}/pc/${encodeURIComponent(registration.name)}/${encodeURIComponent(registration.tag)}`)
                ]);

                console.log('Account API status:', accountData.status);
                console.log('MMR API status:', mmrData.status);
                console.log('Matches API status:', matchData.status);

                if (accountData.status !== 200) {
                    throw new Error(`Account not found - Status: ${accountData.status}`);
                }

                // Calculate enhanced map statistics
                let mapStats = {};
                let agentStats = {};
                let overallStats = {
                    totalKills: 0,
                    totalDeaths: 0,
                    totalAssists: 0,
                    totalMatches: 0,
                    wins: 0,
                    totalACS: 0
                };

                if (matchData.status === 200 && matchData.data) {
                    // Filter for competitive matches only
                    const competitiveMatches = matchData.data.filter(match => 
                        match.metadata && match.metadata.queue.name && match.metadata.queue.name.toLowerCase() === 'competitive'
                    ).slice(0, 20); // Last 20 competitive matches

                    competitiveMatches.forEach(match => {
                        const player = match.players.find(p => p.name.toLowerCase() === registration.name.toLowerCase());
                        if (!player) return;

                        const won = player.team_id === (match.teams.find(t => t.won) || {}).team_id;
                        const mapName = match.metadata.map.name;
                        const agentName = player.agent.name;

                        // Update overall stats
                        overallStats.totalKills += player.stats.kills;
                        overallStats.totalDeaths += player.stats.deaths;
                        overallStats.totalAssists += player.stats.assists;
                        overallStats.totalACS += player.stats.score;
                        overallStats.totalMatches++;
                        if (won) overallStats.wins++;

                        // Track map statistics
                        if (!mapStats[mapName]) {
                            mapStats[mapName] = {
                                games: 0,
                                wins: 0,
                                kills: 0,
                                deaths: 0,
                                assists: 0,
                                totalACS: 0
                            };
                        }
                        mapStats[mapName].games++;
                        if (won) mapStats[mapName].wins++;
                        mapStats[mapName].kills += player.stats.kills;
                        mapStats[mapName].deaths += player.stats.deaths;
                        mapStats[mapName].assists += player.stats.assists;
                        mapStats[mapName].totalACS += player.stats.score;

                        // Track agent statistics
                        if (!agentStats[agentName]) {
                            agentStats[agentName] = {
                                games: 0,
                                wins: 0,
                                kills: 0,
                                deaths: 0,
                                assists: 0
                            };
                        }
                        agentStats[agentName].games++;
                        if (won) agentStats[agentName].wins++;
                        agentStats[agentName].kills += player.stats.kills;
                        agentStats[agentName].deaths += player.stats.deaths;
                        agentStats[agentName].assists += player.stats.assists;
                    });
                }

                const userAvatar = message.author.displayAvatarURL({ extension: 'png', size: 128 });
                const statsImage = await createStatsVisualization(
                    accountData.data, 
                    mmrData.status === 200 ? mmrData.data : null,
                    matchData.status === 200 ? matchData.data : [],
                    userAvatar,
                    registration
                );

                const attachment = new AttachmentBuilder(statsImage.toBuffer(), { name: 'valorant-stats-enhanced.png' });

                const statsEmbed = new EmbedBuilder()
                    .setTitle(`üéØ ${accountData.data.name}#${accountData.data.tag}`)
                    .setColor('#ff4654')
                    .setImage('attachment://valorant-stats-enhanced.png')
                    .setFooter({ text: 'Enhanced stats with KDA analysis ‚Ä¢ Data from stored-matches API ‚Ä¢ Updated in real-time' })
                    .setTimestamp();

                // Current rank section
                if (mmrData.status === 200 && mmrData.data.current_data) {
                    const currentRank = mmrData.data.current_data;
                    const rankInfo = RANK_MAPPING[currentRank.currenttier] || RANK_MAPPING[0];
                    
                    statsEmbed.addFields({
                        name: 'üèÜ Current Rank',
                        value: `**${rankInfo.name}**${currentRank.ranking_in_tier !== undefined ? `\n${currentRank.ranking_in_tier} RR` : ''}`,
                        inline: true
                    });
                }

                // Overall performance stats
                if (overallStats.totalMatches > 0) {
                    const avgKDA = overallStats.totalDeaths > 0 ? ((overallStats.totalKills + overallStats.totalAssists) / overallStats.totalDeaths).toFixed(2) : (overallStats.totalKills + overallStats.totalAssists).toFixed(2);
                    const winRate = ((overallStats.wins / overallStats.totalMatches) * 100).toFixed(0);
                    const avgACS = Math.round(overallStats.totalACS / overallStats.totalMatches);

                    statsEmbed.addFields({
                        name: 'üìä Performance (Last 20)',
                        value: `**${overallStats.wins}W-${overallStats.totalMatches - overallStats.wins}L** (${winRate}% WR)\n**KDA:** ${avgKDA}\n**Avg ACS:** ${avgACS}`,
                        inline: true
                    });
                }

                statsEmbed.addFields({
                    name: 'üìä Account Level',
                    value: accountData.data.account_level.toString(),
                    inline: true
                });

                // Enhanced map statistics section
                if (Object.keys(mapStats).length > 0) {
                    const sortedMaps = Object.entries(mapStats)
                        .sort((a, b) => b[1].games - a[1].games)
                        .slice(0, 5); // Top 5 most played maps

                    let mapStatsText = '';
                    sortedMaps.forEach(([mapName, stats]) => {
                        const winRate = ((stats.wins / stats.games) * 100).toFixed(0);
                        const kda = stats.deaths > 0 ? ((stats.kills + stats.assists) / stats.deaths).toFixed(2) : (stats.kills + stats.assists).toFixed(2);
                        const avgACS = Math.round(stats.totalACS / stats.games);
                        
                        mapStatsText += `**${mapName}**: ${stats.wins}W-${stats.games - stats.wins}L (${winRate}%)\n`;
                        mapStatsText += `‚îî KDA: ${kda} ‚Ä¢ ACS: ${avgACS}\n\n`;
                    });

                    if (mapStatsText.length > 1024) {
                        mapStatsText = mapStatsText.substring(0, 1000) + '...';
                    }

                    statsEmbed.addFields({
                        name: 'üó∫Ô∏è Map Performance (Most Played)',
                        value: mapStatsText || 'No map data available',
                        inline: false
                    });
                }

                // Top agents section
                if (Object.keys(agentStats).length > 0) {
                    const sortedAgents = Object.entries(agentStats)
                        .sort((a, b) => b[1].games - a[1].games)
                        .slice(0, 3); // Top 3 most played agents

                    let agentStatsText = '';
                    sortedAgents.forEach(([agentName, stats]) => {
                        const winRate = ((stats.wins / stats.games) * 100).toFixed(0);
                        const kda = stats.deaths > 0 ? ((stats.kills + stats.assists) / stats.deaths).toFixed(2) : (stats.kills + stats.assists).toFixed(2);
                        
                        agentStatsText += `**${agentName}**: ${stats.games} games (${winRate}% WR, ${kda} KDA)\n`;
                    });

                    statsEmbed.addFields({
                        name: 'üë§ Top Agents',
                        value: agentStatsText || 'No agent data available',
                        inline: false
                    });
                }

                // Last match info
                if (matchData.status === 200 && matchData.data.length > 0) {
                    const recentMatch = matchData.data[0];
                    const player = recentMatch.players.find(p => p.name.toLowerCase() === registration.name.toLowerCase());
                    
                    if (player) {
                        const won = player.team_id === (recentMatch.teams.find(t => t.won) || {}).team_id;
                        const kda = `${player.stats.kills}/${player.stats.deaths}/${player.stats.assists}`;
                        
                        statsEmbed.addFields({
                            name: 'üéÆ Last Match',
                            value: `${won ? '‚úÖ Victory' : '‚ùå Defeat'} on **${recentMatch.metadata.map.name}**\n${player.agent.name} ‚Ä¢ ${kda} ‚Ä¢ ${player.stats.score} ACS`,
                            inline: false
                        });
                    }
                }

                const refreshButton = new ButtonBuilder()
                    .setCustomId(`valstats_refresh_${message.author.id}`)
                    .setLabel('Refresh Stats')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('üîÑ');

                const matchesButton = new ButtonBuilder()
                    .setCustomId(`valmatches_refresh_${message.author.id}`)
                    .setLabel('View Matches')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìã');

                const row = new ActionRowBuilder().addComponents(refreshButton, matchesButton);

                await loadingMessage.edit({ 
                    embeds: [statsEmbed], 
                    files: [attachment],
                    components: [row]
                });

            } catch (error) {
                console.error('Stats error:', error);
                
                const errorEmbed = new EmbedBuilder()
                    .setTitle('‚ùå Error Loading Enhanced Stats')
                    .setColor('#ff0000')
                    .setDescription('There was an error loading your Valorant stats. This could be due to:')
                    .addFields(
                        { name: 'üîß Possible Issues:', value: '‚Ä¢ Riot API is temporarily down\n‚Ä¢ Your account may be private\n‚Ä¢ Network connectivity issues\n‚Ä¢ Rate limit exceeded', inline: false },
                        { name: 'üí° Try:', value: '‚Ä¢ Wait a few minutes and try again\n‚Ä¢ Check if your Valorant account is public\n‚Ä¢ Contact an administrator if the issue persists', inline: false },
                        { name: 'üêõ Error Details:', value: `\`${error.message}\``, inline: false }
                    )
                    .setTimestamp();

                await loadingMessage.edit({ embeds: [errorEmbed], components: [] });
            }
        }

        // New function to show detailed match history
        async function showUserMatches(message, registration) {
            const loadingEmbed = new EmbedBuilder()
                .setTitle('üîÑ Loading Enhanced Match History...')
                .setColor('#ff4654')
                .setDescription('Fetching your recent competitive matches with KDA analysis...')
                .setTimestamp();

            const loadingMessage = await message.channel.send({ embeds: [loadingEmbed] });

            try {
                console.log(`Fetching enhanced matches for: ${registration.name}#${registration.tag} in ${registration.region}`);
                
                const [accountData, matchData] = await Promise.all([
                    makeAPIRequest(`/v1/account/${encodeURIComponent(registration.name)}/${encodeURIComponent(registration.tag)}`),
                    makeAPIRequest(`/v4/matches/${registration.region}/pc/${encodeURIComponent(registration.name)}/${encodeURIComponent(registration.tag)}`)
                ]);

                if (accountData.status !== 200) {
                    throw new Error(`Account not found - Status: ${accountData.status}`);
                }

                if (matchData.status !== 200 || !matchData.data || matchData.data.length === 0) {
                    const noMatchesEmbed = new EmbedBuilder()
                        .setTitle('üìã No Matches Found')
                        .setColor('#ffaa00')
                        .setDescription('No recent matches found for your account.')
                        .addFields(
                            { name: 'üí° Tip', value: 'Play some Valorant matches and try again!', inline: false }
                        )
                        .setTimestamp();

                    return await loadingMessage.edit({ embeds: [noMatchesEmbed] });
                }

                // Filter for competitive matches only
                const competitiveMatches = matchData.data.filter(match => 
                    match.metadata && match.metadata.queue.name && match.metadata.queue.name.toLowerCase() === 'competitive'
                );

                if (competitiveMatches.length === 0) {
                    const noCompMatchesEmbed = new EmbedBuilder()
                        .setTitle('üìã No Competitive Matches Found')
                        .setColor('#ffaa00')
                        .setDescription('No recent competitive matches found for your account.')
                        .addFields(
                            { name: 'üí° Tip', value: 'Play some competitive matches and try again!', inline: false }
                        )
                        .setTimestamp();

                    return await loadingMessage.edit({ embeds: [noCompMatchesEmbed] });
                }

                // Take the last 10 matches
                const recentMatches = competitiveMatches.slice(0, 10);
                
                // Calculate overall stats with enhanced KDA analysis
                let totalKills = 0, totalDeaths = 0, totalAssists = 0, totalACS = 0;
                let wins = 0, losses = 0;
                const mapStats = {};
                const agentStats = {};

                const matchDetails = recentMatches.map((match, index) => {
                    const player = match.players.find(p => p.name.toLowerCase() === registration.name.toLowerCase());
                    if (!player) return null;

                    const won = player.team_id === (match.teams.find(t => t.won) || {}).team_id;
                    const matchDate = new Date(match.metadata.started_at);
                    
                    // Update overall stats
                    totalKills += player.stats.kills;
                    totalDeaths += player.stats.deaths;
                    totalAssists += player.stats.assists;
                    totalACS += player.stats.score;
                    
                    if (won) wins++; else losses++;
                    
                    // Track map stats
                    const mapName = match.metadata.map.name;
                    if (!mapStats[mapName]) mapStats[mapName] = { wins: 0, losses: 0, games: 0 };
                    mapStats[mapName].games++;
                    if (won) mapStats[mapName].wins++; else mapStats[mapName].losses++;
                    
                    // Track agent stats
                    const agentName = player.agent.name;
                    if (!agentStats[agentName]) agentStats[agentName] = { games: 0, wins: 0 };
                    agentStats[agentName].games++;
                    if (won) agentStats[agentName].wins++;

                    const kda = `${player.stats.kills}/${player.stats.deaths}/${player.stats.assists}`;
                    const kdRatio = player.stats.deaths > 0 ? (player.stats.kills / player.stats.deaths).toFixed(2) : player.stats.kills.toFixed(2);
                    const kdaRatio = player.stats.deaths > 0 ? ((player.stats.kills + player.stats.assists) / player.stats.deaths).toFixed(2) : (player.stats.kills + player.stats.assists).toFixed(2);
                    const acs = player.stats.score;
                    
                    // Calculate headshot percentage
                    const totalShots = player.stats.headshots + player.stats.bodyshots + player.stats.legshots;
                    const hsPercent = totalShots > 0 ? Math.round((player.stats.headshots / totalShots) * 100) : 0;

                    return {
                        result: won ? 'üî± WIN' : '‚ùå LOSS',
                        map: mapName,
                        agent: agentName,
                        kda: kda,
                        kdRatio: kdRatio,
                        kdaRatio: kdaRatio,
                        acs: acs,
                        hsPercent: hsPercent,
                        date: matchDate.toLocaleDateString(),
                        rounds: `${match.metadata.rounds_played} rounds`
                    };
                }).filter(match => match !== null);

                if (matchDetails.length === 0) {
                    throw new Error('No valid match data found');
                }

                // Calculate averages and enhanced KDA metrics
                const avgKD = totalDeaths > 0 ? (totalKills / totalDeaths).toFixed(2) : totalKills.toFixed(2);
                const avgKDA = totalDeaths > 0 ? ((totalKills + totalAssists) / totalDeaths).toFixed(2) : (totalKills + totalAssists).toFixed(2);
                const avgACS = Math.round(totalACS / matchDetails.length);
                const winRate = Math.round((wins / (wins + losses)) * 100);

                // Create the main embed
                const matchesEmbed = new EmbedBuilder()
                    .setTitle(`üìä Enhanced Match History - ${accountData.data.name}#${accountData.data.tag}`)
                    .setColor('#ff4654')
                    .setDescription(`**Last ${matchDetails.length} Competitive Matches**`)
                    .addFields(
                        {
                            name: 'üìà Enhanced Performance Metrics',
                            value: `**${wins}W - ${losses}L** (${winRate}% WR)\n` +
                                   `**${totalKills}/${totalDeaths}/${totalAssists}** (${avgKD} K/D | ${avgKDA} KDA)\n` +
                                   `**${avgACS} Avg ACS**`,
                            inline: true
                        },
                        {
                            name: 'üó∫Ô∏è Most Played Maps',
                            value: Object.entries(mapStats)
                                .sort((a, b) => b[1].games - a[1].games)
                                .slice(0, 3)
                                .map(([map, stats]) => `**${map}**: ${stats.wins}W-${stats.losses}L`)
                                .join('\n') || 'No data',
                            inline: true
                        },
                        {
                            name: 'üë§ Most Played Agents',
                            value: Object.entries(agentStats)
                                .sort((a, b) => b[1].games - a[1].games)
                                .slice(0, 3)
                                .map(([agent, stats]) => `**${agent}**: ${stats.games} games (${Math.round((stats.wins/stats.games)*100)}% WR)`)
                                .join('\n') || 'No data',
                            inline: true
                        }
                    )
                    .setTimestamp();

                // Create detailed match list
                let matchList = '';
                matchDetails.forEach((match, index) => {
                    const resultColor = match.result.includes('WIN') ? 'üü¢' : 'üî¥';
                    matchList += `${resultColor} **${match.result}** | ${match.map}\n`;
                    matchList += `‚îî ${match.agent} ‚Ä¢ ${match.kda} (${match.kdRatio} K/D | ${match.kdaRatio} KDA) ‚Ä¢ ${match.acs} ACS ‚Ä¢ ${match.hsPercent}% HS\n`;
                    matchList += `‚îî ${match.date} ‚Ä¢ ${match.rounds}\n\n`;
                });

                // Split into multiple embeds if needed (Discord has field value limits)
                const maxLength = 1024;
                if (matchList.length <= maxLength) {
                    matchesEmbed.addFields({
                        name: 'üéÆ Recent Matches (Enhanced)',
                        value: matchList,
                        inline: false
                    });
                } else {
                    // Split into multiple fields
                    const chunks = [];
                    let currentChunk = '';
                    const lines = matchList.split('\n');
                    
                    for (const line of lines) {
                        if ((currentChunk + line + '\n').length > maxLength) {
                            if (currentChunk) chunks.push(currentChunk);
                            currentChunk = line + '\n';
                        } else {
                            currentChunk += line + '\n';
                        }
                    }
                    if (currentChunk) chunks.push(currentChunk);

                    chunks.forEach((chunk, index) => {
                        matchesEmbed.addFields({
                            name: index === 0 ? 'üéÆ Recent Matches (Enhanced)' : 'üéÆ Recent Matches (cont.)',
                            value: chunk,
                            inline: false
                        });
                    });
                }

                // Add refresh button
                const refreshButton = new ButtonBuilder()
                    .setCustomId(`valmatches_refresh_${message.author.id}`)
                    .setLabel('Refresh Matches')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('üîÑ');

                const backButton = new ButtonBuilder()
                    .setCustomId(`valstats_refresh_${message.author.id}`)
                    .setLabel('Back to Stats')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìä');

                const row = new ActionRowBuilder().addComponents(refreshButton, backButton);

                await loadingMessage.edit({ 
                    embeds: [matchesEmbed], 
                    components: [row]
                });

            } catch (error) {
                console.error('Enhanced matches error:', error);
                
                const errorEmbed = new EmbedBuilder()
                    .setTitle('‚ùå Error Loading Enhanced Matches')
                    .setColor('#ff0000')
                    .setDescription('There was an error loading your match history.')
                    .addFields(
                        { name: 'üîß Possible Issues:', value: '‚Ä¢ Riot API is temporarily down\n‚Ä¢ Network connectivity issues\n‚Ä¢ No recent matches found', inline: false },
                        { name: 'üí° Try:', value: '‚Ä¢ Wait a few minutes and try again\n‚Ä¢ Play some competitive matches\n‚Ä¢ Contact an administrator if the issue persists', inline: false },
                        { name: 'üêõ Error Details:', value: `\`${error.message}\``, inline: false }
                    )
                    .setTimestamp();

                await loadingMessage.edit({ embeds: [errorEmbed], components: [] });
            }
        }
    }
};